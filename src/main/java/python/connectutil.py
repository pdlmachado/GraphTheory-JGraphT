# -*- coding: utf-8 -*-
"""connectutil.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1JEfeHrCB0DKj9PoMZno_rQ5QTOiW9P7r

Este notebook contém funções no escopo de conectividade em grafos.

O código pode ser importado em seu notebook usando o seguinte comando:

!wget https://raw.githubusercontent.com/pdlmachado/GraphTheory-JGraphT/master/src/main/java/python/connectutil.py

Testes para as funções encontram-se neste notebook:

https://colab.research.google.com/drive/1akfgNvX6ic5o_JkCherpqTCotERTOT7A?
"""

# Se desejar compilar, descomente o(s) comando(s) abaixo
#!pip install jgrapht
#!wget https://raw.githubusercontent.com/pdlmachado/GraphTheory-JGraphT/master/src/main/java/python/getutil.py
#!wget https://raw.githubusercontent.com/pdlmachado/GraphTheory-JGraphT/master/src/main/java/python/searchutil.py
#!wget https://raw.githubusercontent.com/pdlmachado/GraphTheory-JGraphT/master/src/main/java/python/rootedtreeutil.py

# Importando funções
from jgrapht import create_graph
from jgrapht.algorithms.cycles import fundamental_cycle_basis_paton
from searchutil import dfs
from rootedtreeutil import is_root,is_leaf,children

"""# Corte de Arestas, Aresta de Corte e Vértice de Corte

## is_bridge

Determina se uma aresta é ponte
"""

def is_bridge(e,g):
  if not (e in g.edges):
    return None
  w,c = fundamental_cycle_basis_paton(g)
  return all(not e in cycle for cycle in c)

"""## is_cutvertex

Determina se um vértice é de corte em um grafo
Recebe como entrada o vértice, o grafo e uma árvore DFS qualquer
"""

def is_cutvertex (v, g, tree):
  if not v in g.vertices:
    return None
  if is_root(v,tree) and len(list(tree.outedges_of(v)))>=2:
    return True #vértice é raiz e possui mais de um filho
  elif is_root(v,tree) or is_leaf(v,tree): 
    return False #vértice é folha ou raiz com menos de 2 filhos
  else:
    #Verifica se nenhum vértice na sub-arvore onde v é raiz é adjacente em g 
    #a ancestrais de v
    ancestors = list(tree.ancestors(v))
    chi = children(v,tree)
    for f in chi:
      subtreev = list(tree.descendants(f)) + [f]
      flag = True
      for d in subtreev:
        a = all(g.contains_edge_between(a,d) == False for a in ancestors)
        flag = flag and a
      if flag:
        return True      
  return False

"""## edge_cut

Retorna um corte (conjunto) de arestas com um terminal em X e outro em Y
"""

def edge_cut(X, g):
  if (all(v in g.vertices for v in X)):
    Y = [v for v in g.vertices if not v in X]
    edges = filter(lambda e: (g.edge_source(e) in X and g.edge_target(e) in Y) or
                             (g.edge_source(e) in Y and g.edge_target(e) in X),g.edges)
    return list(edges)
  return None

"""## outedge_cut

Retorna um corte de saída (conjunto) de arcos com cauda no conjunto de vértices X
"""

def outedge_cut(X, d):
  if all(v in d.vertices for v in X):
    Y = [v for v in d.vertices if not v in X]
    arcs = filter(lambda a: d.edge_source(a) in X and d.edge_target(a) in Y,d.edges)
    return list(arcs)
  return None

"""## inedge_cut

Retorna um corte de entrada (conjunto) de arcos com cabeça no conjunto de vértices X
"""

def inedge_cut(X, d):
  if all(v in d.vertices for v in X):
    Y = [v for v in d.vertices if not v in X]
    arcs = filter(lambda a: ((d.edge_target(a) in X) and (d.edge_source(a) in Y)),d.edges)
    return list(arcs)
  return None