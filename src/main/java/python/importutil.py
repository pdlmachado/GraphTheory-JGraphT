# -*- coding: utf-8 -*-
"""importutil.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1XC9Fp17WP1T8dRBoNzlc0ZNDNmhD4HnD

Este notebook contém funções para importação de grafos.

O código pode ser importado em seu notebook usando o seguinte comando:

!wget https://raw.githubusercontent.com/pdlmachado/GraphTheory-JGraphT/master/src/main/java/python/importutil.py

Testes para as funções encontram-se neste notebook:

https://colab.research.google.com/drive/1X7nngfUSPYOvdi5ej2SGpKNjZyYsn-tG?
"""

# Se desejar compilar, descomente o comando abaixo
#!pip install jgrapht
#import jgrapht

# Importando funções
import csv
from jgrapht.io.importers import parse_gml,parse_graphml,parse_dot
import re

"""## read_multiple_csv

Importa um grafo a partir de tabelas com os conjuntos de vértices e arestas.

Parâmetros:
-   csvgraph - instância do grafo
-   v_attrs - instância do dicionário de atributos de vértices
-   e_attrs - instância do dicionário de atributos de arestas
-   vfilename - arquivo com tabela de vértices no formato CSV
-   vid - atributo que representa vértices na tabela de arestas
-  vlabel - atributo que representa os labels dos vértices (se existir)
-   efilename - arquivo com tabela de arestas no formato CSV
-   esourceid - atributo que representa o vértice origem
-   etargetid - atributo que representa o vértice destino
-   elabel - atributo que representa os labels das arestas (se existir)
-   weightid - atributo que representa o peso das arestas (se existir)
-   delimiter - delimitador utilizado nos arquivos CSV - default: ,
"""

def read_multiple_CSV(csvgraph,v_attrs,e_attrs,
                       vfilename,vid,vlabel,
                       efilename,esourceid,etargetid,elabel='',weightid='',
                       delimiter=','):
  # Vertices
  listcsvV = []
  with open(vfilename, newline='') as f:
    reader = csv.reader(f,delimiter=delimiter)    
    for row in reader:
      listcsvV.append(row)
  f.close()
  viddict = {}
  read_vertices(csvgraph,listcsvV,v_attrs,vid,vlabel,viddict)
  # Arestas
  listcsvE = []
  with open(efilename, newline='') as f:
    reader = csv.reader(f,delimiter=delimiter)    
    for row in reader:
      listcsvE.append(row)
  f.close()
  read_edges(csvgraph,listcsvE,v_attrs,viddict,e_attrs,esourceid,etargetid,elabel,weightid)

def read_vertices(csvgraph,listcsv,v_attrs,vid,vlabel,viddict):  
  headers = listcsv[0]
  vertex_index = headers.index(vid)
  vertexlabel_index = vertex_index
  if vlabel != '':
    vertexlabel_index = headers.index(vlabel)
  #viddict = {}
  for i in range(1,len(listcsv)):
    id = i
    try:
      id = int(listcsv[i][vertex_index])
    except:
      pass
    csvgraph.add_vertex(id)
    viddict[listcsv[i][vertex_index]] = id
    dict = {}
    for j in range(len(headers)):
        dict[headers[j]] = listcsv[i][j]
    if vlabel != '':
      dict['label'] = listcsv[i][vertexlabel_index]
    v_attrs[id] = dict

def read_edges (csvgraph,listcsv,v_attrs,viddict,e_attrs,esourceid,etargetid,elabel,weightid):
  headers = listcsv[0]
  source_index = headers.index(esourceid)
  target_index = headers.index(etargetid)
  edgelabel_index = 0
  if (elabel != ''):
    edgelabel_index = headers.index(elabel)
  weight_index = -1
  if (weightid in headers):
    weight_index = headers.index(weightid)
  for i in range(1,len(listcsv)):
    e = csvgraph.add_edge(viddict[listcsv[i][source_index]],
                          viddict[listcsv[i][target_index]])
    if (weight_index != -1):
      csvgraph.set_edge_weight(e,int(listcsv[i][weight_index]))
    dict = {}
    for j in range(len(headers)):
      if j!=source_index and j!=target_index:
        dict[headers[j]] = listcsv[i][j]
    if (elabel != ''):
      dict['label'] = listcsv[i][edgelabel_index]
    e_attrs[e] = dict

"""## import_gml

Importa grafo no formato GML

Parâmetros:
-   g - instância do grafo
-   v_attrs - instância (vazia) do dicionário de atributos de vértices
-   e_attrs - instância (vazia) do dicionário de atributos de arestas
- filename - nome do arquivo como grafo
- weights_aslabel - indica se o valor do atributo 'label' deve ser usado como peso para o grafo.
"""

def import_gml (g,v_attrs,e_attrs,filename,weights_aslabel=False):
  # Leitura do arquivo em um string de entrada
  gmlfile = open(filename,"r")
  input_gml = "".join(gmlfile.readlines())
  gmlfile.close()
  read_gml (g,input_gml,v_attrs,e_attrs,weights_aslabel)

def read_gml (g,input_gml,v_attrs,e_attrs,weights_aslabel):
  # Função que adiciona atributos de vértices
  def v_att_cb(vertex, attribute_name, attribute_value):
      if vertex not in v_attrs:
          v_attrs[vertex] = {}
      v_attrs[vertex][attribute_name] = attribute_value

  # Função que adiciona atributos de arestas
  def e_att_cb(edge, attribute_name, attribute_value):
      if edge not in e_attrs:
          e_attrs[edge] = {}
      e_attrs[edge][attribute_name] = attribute_value

  # Importando a definição no formato GML
  parse_gml(g,input_gml,
            vertex_attribute_cb=v_att_cb,
            edge_attribute_cb=e_att_cb)
  if weights_aslabel and g.type.weighted:
    for e in g.edges:
      w = int(e_attrs[e]['label'])
      g.set_edge_weight(e,w)

"""# import_dot

Importa grafo no formato DOT

Parâmetros:
-   g - instância do grafo
-   v_attrs - instância (vazia) do dicionário de atributos de vértices
-   e_attrs - instância (vazia) do dicionário de atributos de arestas
- filename - nome do arquivo como grafo

"""

def import_dot (g,v_attrs,e_attrs,filename):
  file = open(filename,"r")
  input_string = re.sub(' \(.*\)','',"".join(file.readlines()))
  file.close()
  read_dot(g,input_string,v_attrs,e_attrs)

def read_dot(g,input_string,v_attrs,e_attrs):  
  # Função que adiciona atributos de vértices
  def v_att_cb(vertex, attribute_name, attribute_value):
      if vertex not in v_attrs:
          v_attrs[vertex] = {}
      v_attrs[vertex]['label'] = attribute_value

  # Função que adiciona atributos de arestas
  def e_att_cb(edge, attribute_name, attribute_value):
      if edge not in e_attrs:
          e_attrs[edge] = {}
      e_attrs[edge][attribute_name] = attribute_value
  parse_dot(g,input_string,vertex_attribute_cb=v_att_cb,edge_attribute_cb=e_att_cb)

"""## create_vdict

Cria dicionário *v_attrs* a partir de *input_string* no formato CSV 
*edgelist* ou *adjacencylist*. Se *weighted=True*, o último
elemento de cada linha será o peso da aresta (para o formato *edgelist*)
"""

def create_vdict (v_attrs, input_string, weighted=False):
  listcsv = input_string.split('\n')
  vlist = []
  count = 0
  for l in listcsv:
    if l!='':
      vertices = l.split(',')
      if weighted:
        vertices.pop(-1)
      for v in vertices:
       if not(v in vlist):
         v_attrs[count] = {}
         v_attrs[count]['label'] = v
         vlist.append(v)
         count += 1